

##' Bin the samples generated by the Metropolis samplers.
##'
##' These functions provide spatial binning of samples. A spatial
##' summary image is stored separately for each time step and may be
##' mosaiced into the entire study region.
##'
##' If \code{pimg} is supplied \code{grid} and \code{proj} are ignored
##' and binning is added to the existing \code{pimg}. If \code{pimg}
##' or is not supplied \code{grid} is used to build one with the
##' details from the fit object, and \code{proj} is ignored. If only
##' \code{proj} is supplied a grid is build using that projection and
##' the details from the fit object.
##'
##' The \code{proj} argument should be a PROJ.4 string, see
##' \code{\link[raster]{projection}} and \code{\link[sp]{CRS}}
##' @title Bin MCMC samples
##' @param fit object with model and samples
##' @param bin samples to bin, "primary" or "intermediate"
##' @param pimg a \code{\link{Pimage}} object
##' @param proj a character string of projection arguments, see Details
##' @param grid a specification for the grid extent and resolution, see Details
##' @return \code{\link{Pimage}}
##' @export
##' @import raster sp
model.bin <- function(fit, bin = c("primary", "intermediate"),
                      pimg = NULL, grid =NULL, proj = NULL) {
  ##TODO:
  ##  checks for out of bounds transformation
  ##  add to existing pimg, currently this is lost



    modeltimes <- fit$model$time
    ##  interaction of bin and .isZ(pimg)
    bin <- match.arg(bin)
    Zarg <- switch(bin,
                    primary = FALSE,
                    intermediate = TRUE)
    Z <- if (!is.null(pimg)) .isZ(pimg) else Zarg

    ## TODO
    ## not sure what to do here . .
    ##    if (Z != Zarg) warning(sprintf("bin=%s argument is incompatible with pimg object, ignored", Zarg))

    chain <- if(Z) fit$z else fit$x

    ## set up tests for map projection, and rgdal availibility
    projected <- FALSE

    ## 3 no pimg, no grid, proj used to build default
    if (is.null(pimg) & is.null(grid) & !is.null(proj)) {
        rextent <- .chaingrid(chain)
        if (!isLonLat(proj)) {
            .check_rgdal()
            projected <- TRUE ## check for both longlat in rextent and proj, otherwise check rgdal avail and
            grid <- projectExtent(rextent, proj)
      } else {
          grid <- rextent
      }
    }
    ## 4 no pimg, no grid, no proj
    if (is.null(pimg) & is.null(grid) & is.null(proj)) {
        grid <- .chaingrid(chain)
    }
    ## 2 no pimg, grid is supplied, proj is ignored
    if (is.null(pimg) & !is.null(grid)) {
        pimg <- Pimage(modeltimes, grid = grid, Z = Z)
        if (!isLonLat(raster(grid))) {
            .check_rgdal()
            proj <- projection(grid)
            projected <- TRUE
        }
    }

    ## 1 pimg is supplied, proj and grid ignored
    ## DONE

    ## we have to transform
    if (projected) {
        mkprojfun <- function(crs) {
           tocrs <- CRS(crs)
           fromcrs <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0")
           function(x) {
               coordinates(spTransform(SpatialPoints(x, fromcrs), tocrs))
           }
       }
       projfun <- mkprojfun(proj)
    }

    times <- .times(pimg)

    if (Z) {
        weights <- diff(times)
        units(weights) <- "hours"  ## could allow user control here
        weights <- as.numeric(weights)  ## R controls the units, and now we drop the class
    } else {
        weights <- rep(1L, length(times))
    }

  for (k in seq_along(weights)) {
      binx <- t(chain[k, 1:2, ])
      if (projected) binx <- projfun(binx)
    pimg[[k]] <- chain.bin(pimg[[k]], binx, weight = weights[k])
  }
  ## should also have a flag for whether this is initialized/scaled, so iter number is independent
  attr(pimg, "itersbin") <- attr(pimg, "itersbin") + dim(chain)[3]
  pimg
}


##' Create object to store binned images.
##'
##' These functions provide a data structure to store binned samples generated by the Metropolis samplers.
##' @title Pimage bin
##' @param tm vector of POSIXct date-times for locations, these are expected to be for the primary estimates
##' @param grid object to use as a template for grid specification
##' @param Z logical, is this a summary of Z (intermediate) location estimates?
##' @return \code{\link{Pimage}}
##' @export
Pimage <- function(tm, grid = NULL, Z = TRUE) {
    stopifnot(inherits(tm, "POSIXct"))
    stopifnot(inherits(Z, "logical"))
    ## not fatal, since this is handy for multiple track-chains
    if(!all(diff(unclass(tm)) > 0)) warning("input time stamps are not monotonically increasing, i.e. they contain duplicates and/or are out of temporal order")
    stopifnot(length(tm) >= 2)


    if (is.null(grid)) {
        grid <- raster()
    } else {
        ## this takes an image() list, raster, SGDF/SPxDF, GridTopology(), extent, file
        grid <- raster(grid)
    }

    n <- length(tm) - Z

    dims <- dim(grid)
  res <- res(grid)
    pbase <- pimg(xmin(grid) + res[1L]/2L, xmax(grid) - res[1L]/2L,
                ymin(grid) + res[2L]/2L, ymax(grid) - res[2L]/2L, dims[2L:1L])
    pim <- vector("list", n)
    for (i in seq_along(pim)) pim[[i]] <- pbase
    .times(pim) <- tm
    ##attr(pim, "times") <- tm

    attr(pim, "Z") <- Z
    class(pim) <- c("Pimage")
    pim
}


pimg <- function (xmin, xmax, ymin, ymax, xydim) {
        res <- list(xbound = c(xmin, xmax, xydim[1L]),
                    ybound = c(ymin, ymax, xydim[2L]),
                    offset = c(1L, 1L), image = NULL)
        res
    }
as.pimg.raster <- function(x) {
    dims <- dim(x)
    res <- res(x)
     pimg(xmin(x) + res[1L]/2L, xmax(x) - res[1L]/2L,
                ymin(x) + res[2L]/2L, ymax(x) - res[2L]/2L, dims[2L:1L])

}

##' @importFrom MASS kde2d bandwidth.nrd
chain.bin <-
  function(pimg, xy, weight = 1, type = c("bin", "kde"), hscale = 0.7) {

    xbnd <- pimg$xbound
    ybnd <- pimg$ybound

    ## Bin the locations into the global image coords
    i <- ceiling(xbnd[3]*(xy[,1]-xbnd[1])/(xbnd[2]-xbnd[1]))
    j <- ceiling(ybnd[3]*(xy[,2]-ybnd[1])/(ybnd[2]-ybnd[1]))
    ## Delete those points outside the global image
    keep <- (i >= 1 & i <= xbnd[3] & j >= 1 & j <= ybnd[3])
    if(any(keep)) {
      i <- i[keep]
      j <- j[keep]

      ## Expand image to new size
      if(is.null(pimg$image)) {
        irange <- range(i)
        jrange <- range(j)
        off <- c(irange[1],jrange[1])
        img <- matrix(0,diff(irange)+1,diff(jrange)+1)
      } else {
        irange0 <- pimg$offset[1]+c(0,nrow(pimg$image)-1)
        jrange0 <- pimg$offset[2]+c(0,ncol(pimg$image)-1)
        irange <- range(i,irange0)
        jrange <- range(j,jrange0)
        off <- c(irange[1],jrange[1])
        if(all(irange==irange0) && all(jrange==jrange0)) {
          ## Keep original image
          img <- pimg$image
        } else {
          ## Expand image
          img <- matrix(0,diff(irange)+1,diff(jrange)+1)
          img[(irange0[1]-off[1]+1):(irange0[2]-off[1]+1),
              (jrange0[1]-off[2]+1):(jrange0[2]-off[2]+1)] <- pimg$image
        }
      }

      ## Add binned points to new image
      img <- img + weight * tabulate(nrow(img) * (j - off[2]) + i + (1 - off[1]), nbins = prod(dim(img)))

      pimg <- list(xbound=xbnd,
                   ybound=ybnd,
                   offset=off,
                   image=img)
      if (type == "kde") {
          x <- as.local.pimg(pimg)
          kde <- kde2d(xy[,1], xy[,2], h = pmax(1, c(bandwidth.nrd(xy[,1]), bandwidth.nrd(xy[,2]))) * hscale,
                       n = c(length(x$x), length(x$y)), lims = c(range(x$x), range(x$y)))
          pimg$image <- kde$z
      }
      class(pimg) <- c("pimg", "list")
    }
    pimg
  }


##' Extract parts of Pimage
##'
##' Extraction can be done in the usual ways by numeric or integer
##' indexes, the result is returned as a
##' \code{\link[raster]{raster}}.
##' @name [
##' @param x Pimage object
##' @param i numeric or logical vector
##' @param j ignored
##' @param drop ignored
##' @aliases [.Pimage
##' @docType methods
##' @rdname Pimage-methods
##' @return RasterLayer
##' @method [ Pimage
##' @S3method [ Pimage
##' @seealso \code{\link{cut.Pimage}} for creating temporal partitions.
##' @export
"[.Pimage" <- function(x, i, j, drop = TRUE, ...) {
  timeobject <- .times(x)

  n <- length(x)
  if(nargs() == 1) n2 <-  n
  if (missing(i)) i <- seq_len(n)

  if (all(class(i) == "logical")) {
    n2 <- sum(i)
    i <- which(i)
  }


  if (all(class(i) == "character")) {
      i <- grep(i, names(x))
  }
  class(x) <- NULL
  val <- NextMethod("[")
  ##browser()
  class(val) <- "Pimage"

  .times(val) <- timeobject
##  attr(val, "times") <- timeobject
  val <- as.image.Pimage(val)
  raster(val)

}


##' cut.Pimage
##'
##' Cut a Pimage object based on a date-time input breaks character string, and return a multi-layer raster
##'
##' @title cut.POSIXt for Pimage
##' @rdname Pimage-methods
##' @param breaks an interval specification, see \code{\link{cut.POSIXt}}
##' @param ... pass arguments to \code{\link{cut.POSIXt}}
##' @method cut Pimage
##' @S3method cut Pimage
##' @return RasterLayer or RasterBrick
##' @export
cut.Pimage <- function(x, breaks, ...) {

  r1 <- x[1]
    datetimes <- .times(x)

    ct <- cut.POSIXt(datetimes, breaks = breaks,  ...)
    ## now rebuild the output

    res <- array(0.0, c(dim(r1)[1:2], nlevels(ct)))
    for (i in seq_len(nlevels(ct))) {
          ## this is the solution to the as.matrix namespace problem (don't use it) MDSumner 2013-07-18
          res[,,i] <- getValues(x[ct == levels(ct)[i]], format='matrix')
      }

  res <- brick(res, xmn=xmin(r1), xmx=xmax(r1), ymn=ymin(r1), ymx=ymax(r1), crs=projection(r1))
  setZ(res, as.POSIXct(levels(ct), tz = "GMT"), name = "datetime")
}



##' @rdname Pimage-methods
##' @aliases print
##' @method print Pimage
##' @S3method print Pimage
##' @export
print.Pimage <- function(x, ...) {
  ## this needs to know the x/y/time range, and possibly the sizes of all images, whether any are NULL or funny
    ext <- extent(x[])
    trange <- format(range(.times(x)))
    Z <- .isZ(x)
    cat("Class    :", class(x), c("(Primary/X)", "(Intermediate/Z)")[Z + 1], "\nLength    :", length(x),  "\nTemporal Extent :", trange, "\n")
    ##cat("Time Steps   :")
    ##str(attr(x, "times"))
    print(ext)
    invisible(NULL)
}


as.local.pimg <- function (pimg)
{
    img <- coords.pimg(pimg)
    img$x <- img$x[pimg$offset[1]:(pimg$offset[1] + nrow(pimg$image) -
        1)]
    img$y <- img$y[pimg$offset[2]:(pimg$offset[2] + ncol(pimg$image) -
        1)]
    img$z <- pimg$image
    img
}


  `as.matrix.pimg` <-
      function(x) {

        pimg <- x
        img <- matrix(0,pimg$xbound[3],pimg$ybound[3])
        if(!is.null(pimg$image)) {
          off <- pimg$offset
          img[off[1]:(off[1]+nrow(pimg$image)-1),
              off[2]:(off[2]+ncol(pimg$image)-1)] <- pimg$image
        }
        img
      }

    `as.image.pimg` <-
      function(pimg) {
        img <- coords.pimg(pimg)
        img$z <- as.matrix.pimg(pimg)
        img
      }
    `coords.pimg` <-
      function(pimg) {
        list(x=seq(pimg$xbound[1],pimg$xbound[2],length=pimg$xbound[3]),
             y=seq(pimg$ybound[1],pimg$ybound[2],length=pimg$ybound[3]))
      }


as.image.Pimage <-
  function (pimgs)
  {
    ## should have checks elsewhere for these NULLs, do they persist when no mixing?
    ## bad <- unlist(lapply(pimgs, function(x) is.null(x$image)))

    res <- as.image.pimg(pimgs[[1]])
    if (length(pimgs) == 1)
      return(res)
    if (all(sapply(pimgs, function(x) is.null(x$image)))) return(res)
    for (i in seq_along(pimgs)[-1]) {
      img <- pimgs[[i]]
      Xpos <- img$offset[1]
      Ypos <- img$offset[2]
      Xind <- Xpos:(Xpos + dim(img$image)[1] - 1)
      Yind <- Ypos:(Ypos + dim(img$image)[2] - 1)
      res$z[Xind, Yind] <- res$z[Xind, Yind] + img$image
    }
    res
  }

.isZ <- function(x) {
    attr(x, "Z")
}
## apply "units" and store times as offset/difftime, allow user to set

.times <- function(x) {
    ## this should be an as.POSIXct method
   res <- attr(x, "times")
    ## if (Z) res <- res[-length(res)] + diff(unclass(res))/2
    res
}

".times<-" <- function(x, value) {
    attr(x, "times") <- value
    x
}
.chaingrid <- function(x) {
  xrange <- range(x[,1,])
  yrange <- range(x[,2,])

  ## need to determine lon/lat aspect and modify default dims
  raster(nrows = 300, ncols = 300,
         xmn = xrange[1L],
         xmx = xrange[2L],
         ymn = yrange[1L],
         ymx = yrange[2L]
         )
}



.check_rgdal <- function() {
            if (!("rgdal" %in% loadedNamespaces())) {
                ns <- try(loadNamespace("rgdal"))
                if (isNamespace(ns)) {
                    message("[loaded the rgdal namespace]")
                } else {
                    msg <- paste("This method requires the rgdal package",
                                 "but is unable to load rgdal namespace",
                                 sep=",")
                    stop(msg)
                }
            }
            invisible(NULL)
        }
