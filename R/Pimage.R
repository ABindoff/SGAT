


##' Bin the samples generated by the Metropolis samplers.
##'
##' These functions provide spatial binning of samples for each time
##' step. A spatial summary image is stored separately for each time
##' step and may be mosaiced into the entire study region.
##'
##' @title Bin MCMC samples
##' @param chain an array of location samples
##' @param pimg a \code{\link{Pimage}} object
##' @return \code{\link{Pimage}}
##' @export
chain.bin <- function(chain, pimg) {

    Z <- attr(pimg, "Z")
    times <- attr(pimg, "times")

    if (Z) weights <- c(diff(unclass(times)/3600)) else weights <- rep(1, length(times))



  for (k in seq_along(weights)) {
    pimg[[k]] <- bin.pimg(pimg[[k]], t(chain[k, 1:2, ]), weight = weights[k])
  }
  ## should also have a flag for whether this is initialized/scaled, so iter number is independent
  attr(pimg, "itersbin") <- attr(pimg, "itersbin") + dim(chain)[3]
  pimg
}


##' Create object to store binned images.
##'
##' These functions provide a data structure to store binned samples generated by the Metropolis samplers.
##' @title Pimage bin
##' @param tm vector of POSIXct date-times for locations
##' @param grid object to use as a template for grid specification
##' @param Z logical, is this a summary of Z (intermediate) location estimates?
##' @return \code{\link{Pimage}}
##' @export
Pimage <- function(tm, grid = NULL, Z = TRUE) {
    stopifnot(inherits(tm, "POSIXct"))
    stopifnot(inherits(Z, "logical"))
    ## not fatal, since this is handy for multiple track-chains
    if(!all(diff(unclass(tm)) > 0)) warning("input time stamps are not monotonically increasing, i.e. they contain duplicates and/or are out of temporal order")
    stopifnot(length(tm) >= 2)

    p0 <- function (xmin, xmax, ymin, ymax, xydim) {
        res <- list(xbound = c(xmin, xmax, xydim[1L]),
                    ybound = c(ymin, ymax, xydim[2L]),
                    offset = c(1, 1), image = NULL)
        res
    }
    if (is.null(grid)) {
        grid <- raster()
    } else {
        ## this takes an image() list, raster, SGDF/SPxDF, GridTopology(), extent, file
        grid <- raster(grid)
    }
    n <- length(tm) - Z

    dims <- dim(grid)

    pbase <- p0(xmin(grid), xmax(grid), ymin(grid), ymax(grid), dims[1L:2L])
    pim <- vector("list", n)
    for (i in seq_along(pim)) pim[[i]] <- pbase
    attr(pim, "times") <- tm

    attr(pim, "Z") <- Z
    class(pim) <- c("Pimage")
    pim
}

bin.pimg <-
  function(pimg, xy, weight = 1) {

    xbnd <- pimg$xbound
    ybnd <- pimg$ybound

    ## Bin the locations into the global image coords
    i <- ceiling(xbnd[3]*(xy[,1]-xbnd[1])/(xbnd[2]-xbnd[1]))
    j <- ceiling(ybnd[3]*(xy[,2]-ybnd[1])/(ybnd[2]-ybnd[1]))
    ## Delete those points outside the global image
    keep <- (i >= 1 & i <= xbnd[3] & j >= 1 & j <= ybnd[3])
    if(any(keep)) {
      i <- i[keep]
      j <- j[keep]

      ## Expand image to new size
      if(is.null(pimg$image)) {
        irange <- range(i)
        jrange <- range(j)
        off <- c(irange[1],jrange[1])
        img <- matrix(0,diff(irange)+1,diff(jrange)+1)
      } else {
        irange0 <- pimg$offset[1]+c(0,nrow(pimg$image)-1)
        jrange0 <- pimg$offset[2]+c(0,ncol(pimg$image)-1)
        irange <- range(i,irange0)
        jrange <- range(j,jrange0)
        off <- c(irange[1],jrange[1])
        if(all(irange==irange0) && all(jrange==jrange0)) {
          ## Keep original image
          img <- pimg$image
        } else {
          ## Expand image
          img <- matrix(0,diff(irange)+1,diff(jrange)+1)
          img[(irange0[1]-off[1]+1):(irange0[2]-off[1]+1),
              (jrange0[1]-off[2]+1):(jrange0[2]-off[2]+1)] <- pimg$image
        }
      }

      ## Add binned points to new image
      img <- img + weight * tabulate(nrow(img) * (j - off[2]) + i + (1 - off[1]), nbins = prod(dim(img)))

      pimg <- list(xbound=xbnd,
                   ybound=ybnd,
                   offset=off,
                   image=img)
      class(pimg) <- c("pimg", "list")
    }
    pimg
  }


##' @rdname chain.bin
##' @export

"[.Pimage" <- function(x, i, j, drop = TRUE, ...) {
  timeobject <- .times(x)

  n <- length(x)
  if(nargs() == 1) n2 <-  n
  if (missing(i)) i <- seq_len(n)

  if (all(class(i) == "logical")) {
    n2 <- sum(i)
    i <- which(i)
  }


  if (all(class(i) == "character")) {
      i <- grep(i, names(x))
  }
  class(x) <- NULL
  val <- NextMethod("[")
  ##browser()
  class(val) <- "Pimage"

  attr(val, "times") <- timeobject
  val <- as.image.Pimage(val)
  raster(val)

}


##' cut.Pimage
##' 
##' cut a Pimage object based on a cut.POSIXt input breaks character string, and return a brick
##' ##importMethodsFrom(raster, as.matrix)
##' @examples
##' \dontrun{
##' load("C:\\Users\\mdsumner\\Desktop\\Movement_fit.Rdata")
##'  library(SGAT)
##' p <- Pimage(fit$model$twilight, grid = SGAT:::.chaingrid(fit$z))
##' p <- chain.bin(fit$z, p)
##' image(p[], col = trip::oc.colors(256))
##' b <- cut.Pimage(p, "2 weeks")
##' @export
cut.Pimage <- function(x, breaks, ...) {
    pobject <- x
    r <- pobject[1]
    x <- .times(x)
    ##NextMethod("cut")
    x <- cut.POSIXt(x, breaks = breaks,  ...)
    ## now rebuild the output
    
    ## to save that nasty error
  if (length(x) > length(pobject)) x <- x[seq_len(length(pobject))]
    ## do we need an as.raster workhorse here?
    ## Error in as.vector(data) : 
    ##no method for coercing this S4 class to a vector
      res <- array(0.0, c(dim(r)[1:2], nlevels(x)))
    
    
    ##this is probably slow, better to as.matrix into an array and rebuild
    ## (annoyingly, as.matrix does not work here in the namespace)
    ##brick(pobject[1], nl = nlevels(x), values = FALSE)
    ## 
    
    
    for (i in seq_len(nlevels(x))) {
          ##res[,,i] <- matrix(getValues(pobject[x == levels(x)[i]], dim(res)[1]))
          res[,,i] <- raster:::as.matrix(pobject[x == levels(x)[i]])
      }

  brick(res, xmn=xmin(r), xmx=xmax(r), ymn=ymin(r), ymx=ymax(r), crs=projection(r))
       }

as.image.Pimage <-
  function (pimgs)
  {
    ## should have checks elsewhere for these NULLs, do they persist when no mixing?
    ## bad <- unlist(lapply(pimgs, function(x) is.null(x$image)))
    `as.matrix.pimg` <-
      function(x) {

        pimg <- x
        img <- matrix(0,pimg$xbound[3],pimg$ybound[3])
        if(!is.null(pimg$image)) {
          off <- pimg$offset
          img[off[1]:(off[1]+nrow(pimg$image)-1),
              off[2]:(off[2]+ncol(pimg$image)-1)] <- pimg$image
        }
        img
      }

    `as.image.pimg` <-
      function(pimg) {
        img <- coords.pimg(pimg)
        img$z <- as.matrix.pimg(pimg)
        img
      }
    `coords.pimg` <-
      function(pimg) {
        list(x=seq(pimg$xbound[1],pimg$xbound[2],length=pimg$xbound[3]),
             y=seq(pimg$ybound[1],pimg$ybound[2],length=pimg$ybound[3]))
      }

    res <- as.image.pimg(pimgs[[1]])
    if (length(pimgs) == 1)
      return(res)
    if (all(sapply(pimgs, function(x) is.null(x$image)))) return(res)
    for (i in seq_along(pimgs)[-1]) {
      img <- pimgs[[i]]
      Xpos <- img$offset[1]
      Ypos <- img$offset[2]
      Xind <- Xpos:(Xpos + dim(img$image)[1] - 1)
      Yind <- Ypos:(Ypos + dim(img$image)[2] - 1)
      res$z[Xind, Yind] <- res$z[Xind, Yind] + img$image
    }
    res
  }


.times <- function(x, Z = FALSE) {
    ## this should be an as.POSIXct method
   res <- attr(x, "times")
    if (Z) res <- res[1] + diff(unclass(res))/2
    res
}

.chaingrid <- function(x) {
  xrange <- range(x[,1,])
  yrange <- range(x[,2,])
  raster(nrows = 300, ncols = 300,
         xmn = xrange[1L],
         xmx = xrange[2L],
         ymn = yrange[1L],
         ymx = yrange[2L]
         )
}

