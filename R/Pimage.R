


##' Bin the samples generated by the Metropolis samplers.
##'
##' These functions provide spatial binning of samples for each time
##' step. A spatial summary image is stored separately for each time
##' step and may be mosaiced into the entire study region.
##'
##' @title Bin MCMC samples
##' @param chain an array of location samples
##' @param pimg a \code{\link{Pimage}} object
##' @return \code{\link{Pimage}}
##' @export
chain.bin <- function(chain, pimg) {

    Z <- attr(pimg, "Z")
    times <- attr(pimg, "times")

    if (Z) weights <- c(diff(unclass(times)/3600)) else weights <- rep(1, length(times))

    
    
  for (k in seq_along(weights)) {
    pimg[[k]] <- bin.pimg(pimg[[k]], t(chain[k, 1:2, ]), weight = weights[k])
  }
  ## should also have a flag for whether this is initialized/scaled, so iter number is independent
  attr(pimg, "itersbin") <- attr(pimg, "itersbin") + dim(chain)[3]
  pimg
}


##' Create object to store binned images.
##'
##' These functions provide a data structure to store binned samples generated by the Metropolis samplers.
##' @title Pimage bin
##' @param tm vector of POSIXct date-times for locations
##' @param grid object to use as a template for grid specification
##' @param Z logical, is this a summary of Z (intermediate) location estimates?
##' @return \code{\link{Pimage}}
##' @export
##' @importFrom raster raster xmin  xmax ymin ymax
Pimage <- function(tm, grid = NULL, Z = TRUE) {
    stopifnot(inherits(tm, "POSIXct"))
    stopifnot(inherits(Z, "logical"))
    stopifnot(all(diff(unclass(tm)) > 0))
    stopifnot(length(tm) >= 2)

    p0 <- function (xmin, xmax, ymin, ymax, xydim) {
        res <- list(xbound = c(xmin, xmax, xydim[1L]),
                    ybound = c(ymin, ymax, xydim[2L]),
                    offset = c(1, 1), image = NULL)
        res
    }
    if (is.null(grid)) {
        grid <- raster()
    } else {
        ## this takes an image() list, raster, SGDF/SPxDF, GridTopology(), extent, file
        grid <- raster(grid)
    }
    n <- length(tm) - Z

    dims <- dim(grid)

    pbase <- p0(xmin(grid), xmax(grid), ymin(grid), ymax(grid), dims[1L:2L])
    pim <- vector("list", n)
    for (i in seq_along(pim)) pim[[i]] <- pbase
    attr(pim, "times") <- tm

    attr(pim, "Z") <- Z
    class(pim) <- c("Pimage")
    pim
}

bin.pimg <-
  function(pimg, xy, weight = 1) {

    xbnd <- pimg$xbound
    ybnd <- pimg$ybound

    ## Bin the locations into the global image coords
    i <- ceiling(xbnd[3]*(xy[,1]-xbnd[1])/(xbnd[2]-xbnd[1]))
    j <- ceiling(ybnd[3]*(xy[,2]-ybnd[1])/(ybnd[2]-ybnd[1]))
    ## Delete those points outside the global image
    keep <- (i >= 1 & i <= xbnd[3] & j >= 1 & j <= ybnd[3])
    if(any(keep)) {
      i <- i[keep]
      j <- j[keep]

      ## Expand image to new size
      if(is.null(pimg$image)) {
        irange <- range(i)
        jrange <- range(j)
        off <- c(irange[1],jrange[1])
        img <- matrix(0,diff(irange)+1,diff(jrange)+1)
      } else {
        irange0 <- pimg$offset[1]+c(0,nrow(pimg$image)-1)
        jrange0 <- pimg$offset[2]+c(0,ncol(pimg$image)-1)
        irange <- range(i,irange0)
        jrange <- range(j,jrange0)
        off <- c(irange[1],jrange[1])
        if(all(irange==irange0) && all(jrange==jrange0)) {
          ## Keep original image
          img <- pimg$image
        } else {
          ## Expand image
          img <- matrix(0,diff(irange)+1,diff(jrange)+1)
          img[(irange0[1]-off[1]+1):(irange0[2]-off[1]+1),
              (jrange0[1]-off[2]+1):(jrange0[2]-off[2]+1)] <- pimg$image
        }
      }

      ## Add binned points to new image
      img <- img + weight * tabulate(nrow(img) * (j - off[2]) + i + (1 - off[1]), nbins = prod(dim(img)))

      pimg <- list(xbound=xbnd,
                   ybound=ybnd,
                   offset=off,
                   image=img)
      class(pimg) <- c("pimg", "list")
    }
    pimg
  }


.times <- function(x, Z = FALSE) {
    ## this should be an as.POSIXct method
   res <- attr(x, "times")
    if (Z) res <- res[1] + diff(unclass(res))/2
    res
}

.chaingrid <- function(x) {
  xrange <- range(x[,1,])
  yrange <- range(x[,2,])
  raster(nrows = 300, ncols = 300,
         xmn = xrange[1L],
         xmx = xrange[2L],
         ymn = yrange[1L],
         ymx = yrange[2L]
         )
}

