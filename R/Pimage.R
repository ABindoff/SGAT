
##' TODO:
##'
##'
##' try reading environmental data onto grids


##' Bin the samples generated by the Metropolis samplers.
##'
##' These functions provide spatial binning of samples for each time
##' step. A spatial summary image is stored separately for each time
##' step and may be mosaiced into the entire study region.
##'
##' @title Bin MCMC samples
##' @param chain an array of location samples
##' @param pimg a \code{\link{Pimage}} object
##' @return \code{\link{Pimage}}
##' @export
chain.bin <- function(chain, pimg) {
    Z <- .isZ(pimg)
    times <- .times(pimg)

    if (Z) {
        weights <- diff(times)
        units(weights) <- "hours"  ## could allow user control here
        weights <- as.numeric(weights)  ## R controls the units, and now we drop the class
    } else {
        weights <- rep(1L, length(times))
    }

  for (k in seq_along(weights)) {
    pimg[[k]] <- bin.pimg(pimg[[k]], t(chain[k, 1:2, ]), weight = weights[k])
  }
  ## should also have a flag for whether this is initialized/scaled, so iter number is independent
  attr(pimg, "itersbin") <- attr(pimg, "itersbin") + dim(chain)[3]
  pimg
}


##' Create object to store binned images.
##'
##' These functions provide a data structure to store binned samples generated by the Metropolis samplers.
##' @title Pimage bin
##' @param tm vector of POSIXct date-times for locations, these are expected to be for the primary estimates
##' @param grid object to use as a template for grid specification
##' @param Z logical, is this a summary of Z (intermediate) location estimates?
##' @return \code{\link{Pimage}}
##' @export
Pimage <- function(tm, grid = NULL, Z = TRUE) {
    stopifnot(inherits(tm, "POSIXct"))
    stopifnot(inherits(Z, "logical"))
    ## not fatal, since this is handy for multiple track-chains
    if(!all(diff(unclass(tm)) > 0)) warning("input time stamps are not monotonically increasing, i.e. they contain duplicates and/or are out of temporal order")
    stopifnot(length(tm) >= 2)

    p0 <- function (xmin, xmax, ymin, ymax, xydim) {
        res <- list(xbound = c(xmin, xmax, xydim[1L]),
                    ybound = c(ymin, ymax, xydim[2L]),
                    offset = c(1L, 1L), image = NULL)
        res
    }
    if (is.null(grid)) {
        grid <- raster()
    } else {
        ## this takes an image() list, raster, SGDF/SPxDF, GridTopology(), extent, file
        grid <- raster(grid)
    }

    n <- length(tm) - Z

    dims <- dim(grid)
  res <- res(grid)
    pbase <- p0(xmin(grid) + res[1L]/2L, xmax(grid) - res[1L]/2L, 
                ymin(grid) + res[2L]/2L, ymax(grid) - res[2L]/2L, dims[2L:1L])
    pim <- vector("list", n)
    for (i in seq_along(pim)) pim[[i]] <- pbase
    .times(pim) <- tm
    ##attr(pim, "times") <- tm

    attr(pim, "Z") <- Z
    class(pim) <- c("Pimage")
    pim
}

bin.pimg <-
  function(pimg, xy, weight = 1) {

    xbnd <- pimg$xbound
    ybnd <- pimg$ybound

    ## Bin the locations into the global image coords
    i <- ceiling(xbnd[3]*(xy[,1]-xbnd[1])/(xbnd[2]-xbnd[1]))
    j <- ceiling(ybnd[3]*(xy[,2]-ybnd[1])/(ybnd[2]-ybnd[1]))
    ## Delete those points outside the global image
    keep <- (i >= 1 & i <= xbnd[3] & j >= 1 & j <= ybnd[3])
    if(any(keep)) {
      i <- i[keep]
      j <- j[keep]

      ## Expand image to new size
      if(is.null(pimg$image)) {
        irange <- range(i)
        jrange <- range(j)
        off <- c(irange[1],jrange[1])
        img <- matrix(0,diff(irange)+1,diff(jrange)+1)
      } else {
        irange0 <- pimg$offset[1]+c(0,nrow(pimg$image)-1)
        jrange0 <- pimg$offset[2]+c(0,ncol(pimg$image)-1)
        irange <- range(i,irange0)
        jrange <- range(j,jrange0)
        off <- c(irange[1],jrange[1])
        if(all(irange==irange0) && all(jrange==jrange0)) {
          ## Keep original image
          img <- pimg$image
        } else {
          ## Expand image
          img <- matrix(0,diff(irange)+1,diff(jrange)+1)
          img[(irange0[1]-off[1]+1):(irange0[2]-off[1]+1),
              (jrange0[1]-off[2]+1):(jrange0[2]-off[2]+1)] <- pimg$image
        }
      }

      ## Add binned points to new image
      img <- img + weight * tabulate(nrow(img) * (j - off[2]) + i + (1 - off[1]), nbins = prod(dim(img)))

      pimg <- list(xbound=xbnd,
                   ybound=ybnd,
                   offset=off,
                   image=img)
      class(pimg) <- c("pimg", "list")
    }
    pimg
  }


##' @rdname chain.bin
##' @export

"[.Pimage" <- function(x, i, j, drop = TRUE, ...) {
  timeobject <- .times(x)

  n <- length(x)
  if(nargs() == 1) n2 <-  n
  if (missing(i)) i <- seq_len(n)

  if (all(class(i) == "logical")) {
    n2 <- sum(i)
    i <- which(i)
  }


  if (all(class(i) == "character")) {
      i <- grep(i, names(x))
  }
  class(x) <- NULL
  val <- NextMethod("[")
  ##browser()
  class(val) <- "Pimage"

  .times(val) <- timeobject
##  attr(val, "times") <- timeobject
  val <- as.image.Pimage(val)
  raster(val)

}


##' cut.Pimage
##'
##' cut a Pimage object based on a date-time input breaks character string, and return a multi-layer raster
##'
##' @title cut.POSIXt for Pimage
##' @aliases cut
##'
##' @examples
##' \dontrun{
##' load("Movement_fit.Rdata")
##'
##' p <- Pimage(fit$model$twilight, grid = SGAT:::.chaingrid(fit$z))
##' p <- chain.bin(fit$z, p)
##' image(p[], col = trip::oc.colors(256))
##' b <- cut(p, "2 weeks")
##' ## odd time intervals work the same as cut.POSIXt
##'b <- cut(p, "86000 secs")
##'
##'
##'b <- cut(p, "21 days")
##'
##'## the object knows what this 3rd dimension is
##'getZ(b)
##'
##'occol <- c("#FFFFFF", "#975FFF", "#4860FF", "#0070FF", "#00A5FF", "#23C0FF",
##'           "#6CC0FF", "#58CBD8", "#22DEA2", "#0ECE4B", "#06C300", "#3CE700",
##'           "#6BFF00", "#8FFF00", "#B7FF00", "#DCFF00", "#FAFF00", "#FFE000",
##'           "#FFBC00", "#FF9800", "#FF7400", "#FF4A00", "#FF1400", "#DE0000",
##'           "#AA0000")
##'plot(b, col = occol)
##'
##'library(maptools)
##'data(wrld_simpl)
##'plot(b, col = occol, addfun = function() {plot(wrld_simpl, add = TRUE);box()})
##'
##' }
##' @export
cut.Pimage <- function(x, breaks, ...) {

  r1 <- x[1]
    datetimes <- .times(x)

    ct <- cut.POSIXt(datetimes, breaks = breaks,  ...)
    ## now rebuild the output

    res <- array(0.0, c(dim(r1)[1:2], nlevels(ct)))
    for (i in seq_len(nlevels(ct))) {
          ## this is the solution to the as.matrix namespace problem (don't use it) MDSumner 2013-07-18
          res[,,i] <- getValues(x[ct == levels(ct)[i]], format='matrix')
      }

  res <- brick(res, xmn=xmin(r1), xmx=xmax(r1), ymn=ymin(r1), ymx=ymax(r1), crs=projection(r1))
  setZ(res, as.POSIXct(levels(ct), tz = "GMT"), name = "datetime")
}

as.image.Pimage <-
  function (pimgs)
  {
    ## should have checks elsewhere for these NULLs, do they persist when no mixing?
    ## bad <- unlist(lapply(pimgs, function(x) is.null(x$image)))
    `as.matrix.pimg` <-
      function(x) {

        pimg <- x
        img <- matrix(0,pimg$xbound[3],pimg$ybound[3])
        if(!is.null(pimg$image)) {
          off <- pimg$offset
          img[off[1]:(off[1]+nrow(pimg$image)-1),
              off[2]:(off[2]+ncol(pimg$image)-1)] <- pimg$image
        }
        img
      }

    `as.image.pimg` <-
      function(pimg) {
        img <- coords.pimg(pimg)
        img$z <- as.matrix.pimg(pimg)
        img
      }
    `coords.pimg` <-
      function(pimg) {
        list(x=seq(pimg$xbound[1],pimg$xbound[2],length=pimg$xbound[3]),
             y=seq(pimg$ybound[1],pimg$ybound[2],length=pimg$ybound[3]))
      }

    res <- as.image.pimg(pimgs[[1]])
    if (length(pimgs) == 1)
      return(res)
    if (all(sapply(pimgs, function(x) is.null(x$image)))) return(res)
    for (i in seq_along(pimgs)[-1]) {
      img <- pimgs[[i]]
      Xpos <- img$offset[1]
      Ypos <- img$offset[2]
      Xind <- Xpos:(Xpos + dim(img$image)[1] - 1)
      Yind <- Ypos:(Ypos + dim(img$image)[2] - 1)
      res$z[Xind, Yind] <- res$z[Xind, Yind] + img$image
    }
    res
  }

.isZ <- function(x) {
    attr(x, "Z")
}
## apply "units" and store times as offset/difftime, allow user to set

.times <- function(x) {
    ## this should be an as.POSIXct method
   res <- attr(x, "times")
    ## if (Z) res <- res[-length(res)] + diff(unclass(res))/2
    res
}

".times<-" <- function(x, value) {
    attr(x, "times") <- value
    x
}
.chaingrid <- function(x) {
  xrange <- range(x[,1,])
  yrange <- range(x[,2,])
  raster(nrows = 300, ncols = 300,
         xmn = xrange[1L],
         xmx = xrange[2L],
         ymn = yrange[1L],
         ymx = yrange[2L]
         )
}

