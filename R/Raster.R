##' Bin locations to form a 2D density raster
##'
##' Constucts either a 2D histogram or kernel density estimate from
##' the samples for a sequence of locations.  Optionally, a vector of
##' weights can be provided to differentially weight samples by
##' location.
##'
##' @title Location Density Raster
##' @param s an array of location samples generated by
##' \code{estelle.metropolis} or \code{stella.metropolis}.
##' @param grid raster object that defines the sampling grid
##' @param weights weights for each location
##' @param bw optional bandwidth for the kernel density estimator.
##' @param zero.is.na if \code{TRUE}, zero counts are returned as \code{NA}.
##' @return a raster representing a 2D histogram of locations
##' @export
location.rasterize <- function(s,grid,weights=1,zero.is.na=TRUE) {
  if(length(dim(s))==4L) s <- chain.collapse(s)
  weights <- rep(weights,length=dim(s)[1L])
  r <- if(is.null(grid)) raster() else raster(grid)

  ## Project coords
  if(!isLonLat(r)) {
    from <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0")
    to <- CRS(projection(r))
    p <- cbind(as.vector((s[,1L,]+180)%%360-180),as.vector(s[,2L,]))
    p <- coordinates(spTransform(SpatialPoints(p),from),to)
    s[,1L,] <- p[,1L]
    s[,2L,] <- p[,2L]
  }

  ## Do the binning
  bb <- bbox(r)
  nx <- ncol(r)
  ny <- nrow(r)
  xbin <- seq.int(bb[1L,1L],bb[1L,2L],length.out=nx+1L)
  ybin <- seq.int(bb[2L,1L],bb[2L,2L],length.out=ny+1L)

  A <- 0
  W <- dim(s)[3L]
  for(k in seq_len(dim(s)[1L])) {
    A <- A+(weights[k]/W)*table(
      factor((ny+1)-.bincode(s[k,2L,],ybin,TRUE,TRUE),levels=1:ny),
      factor(.bincode(s[k,1L,],xbin,TRUE,TRUE),levels=1:nx))
  }
  if(zero.is.na) A[A==0] <- NA
  values(r) <- A
  r
}



##' @rdname location.rasterize
##' @export
location.kernelize <- function(s,grid,weights=1,bw=NULL,zero.is.na=TRUE) {

  bandwidth <- function (x) {
    1.06*min(sqrt(var(x)),diff(quantile(x,c(0.25,0.75)))/1.34)*length(x)^(-1/5)
  }

  if(length(dim(s))==4L) s <- chain.collapse(s)
  weights <- rep(weights,length=dim(s)[1L])
  r <- if(is.null(grid)) raster() else raster(grid)

  ## Project coords
  if(!isLonLat(r)) {
    from <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0")
    to <- CRS(projection(r))
    p <- cbind(as.vector((s[,1L,]+180)%%360-180),as.vector(s[,2L,]))
    p <- coordinates(spTransform(SpatialPoints(p),from),to)
    s[,1L,] <- p[,1L]
    s[,2L,] <- p[,2L]
  }

  ## Evaluate kernels
  bw <- if(is.null(bw)) c(bandwidth(s[,1L,]),bandwidth(s[,2L,])) else rep(bw/4,length.out=2L)
  xcell <- xFromCol(r)
  ycell <- yFromRow(r)

  A <- 0
  W <-dim(s)[3L]*prod(bw)
  for(k in seq_len(dim(s)[1L])) {
      A <- A+(weights[k]/W)*tcrossprod(dnorm(outer(xcell,s[k,1L,],"-")/bw[1L]),
                                       dnorm(outer(ycell,s[k,2L,],"-")/bw[2L]))
  }
  if(zero.is.na) A[A==0] <- NA
  values(r) <- A
  r
}



##' Generate density estimates for time slices of a trip
##'
##' These functions allow a trip to be divided into time slices, and
##' location density estimates generated for each time slice.
##'
##' The \code{slices} function defines the slices into which the
##' trip is divided, and whether the primary or intermediate locations
##' are to be binned. If \code{breaks} is NULL, each location forms a
##' separate time slice, otherwise \code{breaks} divides the trip into
##' time slices in the same style as \code{\link{cut.POSIXt}}.  A
##' default set of samples and a raster defining the spatial bins may
##' also be specified.
##'
##' The \code{slice} function generates the binned locations for a
##' single time slice as a raster, \code{slice.interval} returns the
##' corresponding time interval, and \code{slice.indices} returns the
##' indices that will yield non null raster.
##'
##' @title Location Density Estimates
##' @param type construct density rasters for primary (\code{"x"}) or
##' intermediate (\code{"z"}) locations
##' @param slices an object generated by \code{slices} defining the
##' @param k the index of the time slice to bin.
##' @param breaks NULL, or a specification suitable for
##' \code{cut.POSIXt} to define the time slices to bin.
##' @param mcmc object generated by generated by
##' \code{estelle.metropolis} or \code{stella.metropolis}.
##' @param grid raster object that defines the sampling grid
##' @param include.lowest parameter to \code{cut.POISXt}.
##' @param right parameter to \code{cut.POSIXt}
##' @param chains NULL or the subset of chains to bin.
##' @param zero.is.na if \code{TRUE}, zero counts are returned as \code{NA}.
##' @return \code{slice} returns the locations for time slice of the
##' track binned into a raster, \code{slices} returns a slices
##' object that defines the time slices into which to bin,
##' \code{slice.interval} returns the time interval spanned by a
##' slice, and \code{slice.indices} returns the valid set of indices
##' that will yield a raster.
##' @export
slice <- function(slices,k,mcmc=slices$mcmc,grid=slices$grid,
                  chains=NULL,zero.is.na=TRUE) {
  ## Split times
  time <- mcmc$model$time
  if(!is.null(slices$breaks))
    k <- which(k==unclass(cut(if(slices$type=="z") time[-length(time)] else time,
                 slices$breaks,
                 include.lowest=slices$include.lowest,
                 right=slices$right)))
  if(length(k)>0) {
    ## Select x or z
    if(slices$type=="z") {
      w <- diff(as.numeric(time)/(60*60))
      s <- mcmc$z
    } else {
      w <- rep(1,length(time))
      s <- mcmc$x
    }

    ## Subset
    w <- w[k]
    if(length(dim(s))==4L) {
      s <- if(is.null(chains)) s[k,,,,drop=FALSE] else s[k,,,chains,drop=FALSE]
    } else {
      s <- s[k,,,drop=FALSE]
    }
    ## Convert
    location.rasterize(s,grid,w,zero.is.na)
  }
}


##' @rdname slice
##' @export
slices <- function(type=c("x","z"),breaks=NULL,
                   mcmc=NULL,grid=raster(),
                   include.lowest=TRUE,right=FALSE) {
  r <- list(type=match.arg(type),
            breaks=breaks,
            mcmc=mcmc,
            grid=grid,
            include.lowest=include.lowest,
            right=right)
  class(r) <- "slices"
  r
}


##' @rdname slice
##' @export
slice.interval <- function(slices,k,mcmc=slices$mcmc) {
  time <- mcmc$model$time
  if(!is.null(slices$breaks))
    k <- which(k==unclass(cut(if(slices$type=="z") time[-length(time)] else time,
                 slices$breaks,
                 include.lowest=slices$include.lowest,
                 right=slices$right)))
  if(length(k)>0) range(time[if(slices$type=="z") c(k,k+1L) else k])
}

##' @rdname slice
##' @export
slice.indices <- function(slices,mcmc=slices$mcmc) {
  time <- mcmc$model$time
  if(slices$type=="z") time <- time[-length(time)]
  if(!is.null(slices$breaks))
    unique(unclass(cut(time,
                       slices$breaks,
                       include.lowest=slices$include.lowest,
                       right=slices$right)))
  else
    1:length(time)
}


##' Extract longitude and latitude of raster cells.
##'
##' Extract the longitude and latitude of the center of the requested
##' cells of a Raster* object, similar to \code{xyFromCell}.
##' @title Raster cell longitude and latitudes
##' @param raster a raster object
##' @param cells the cell numbers
##' @param spatial return locations as SpatialPoints object instead of a matrix.
##' @return the long,lat locations for the requested cells.
##' @export
longlatFromCell <- function(raster,cells,spatial=FALSE) {
  if(isLonLat(raster)) {
    xyFromCell(raster,cells,spatial=spatial)
  } else {
    p <- spTransform(xyFromCell(raster,cells,spatial=TRUE),
                     CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"))
    if(spatial) p else coordinates(p)
  }
}

##' Spatial maps of twilight residuals
##'
##' This function calculates the twilight residuals corresponding to
##' an observed twilight across a grid of locations.
##'
##' @title Twilight Residuals
##' @param twilight an observed time of twilight
##' @param rise \code{TRUE} if twilight is a sunrise
##' @param grid raster object that define the sampling grid.
##' @param zenith the solar zenith angle that defines twilight.
##' @return a raster of twilight residuals (in minutes).
##' @export
solar.residuals <- function(twilight,rise,grid,zenith=96) {
  p <- longlatFromCell(grid,1:ncell(grid))
  legal <- !(is.na(p[,1L]) | is.na(p[,2L]))
  sgn <- if(rise) 1 else -1
  s <- solar(twilight)
  r <- raster(grid)
  r[legal] <- 4*sgn*(s$solarTime-twilight.solartime(s,p[legal,1L],p[legal,2L],rise,zenith))
  r
}
