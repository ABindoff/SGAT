##' Bin locations to form a 2D density raster
##'
##' Bins the samples for a sequence of locations to produce a raster.
##' Optionally, a vector of weights can be provided to differentially
##' weight samples by location.
##'
##' @title Location Density Raster
##' @param s an array of location samples generated by
##' \code{estelle.metropolis} or \code{stella.metropolis}.
##' @param grid raster object that defines the sampling grid
##' @param weights weights for each location
##' @param a raster representing a 2D histogram of locations
##' @export
location.rasterize <- function(s,grid,weights=1) {
  if(length(dim(s))==4) s <- chain.collapse(s)
  weights <- rep(weights,length=dim(s)[1])
  r <- if(is.NULL(grid)) raster() else raster(grid)

  ## Project coords
  if(!isLonLat(r)) {
    from <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0")
    p <- cbind(as.vector((s[,1,]+180)%%360-180),as.vector(s[,2,]))
    p <- coordinates(spTransform(SpatialPoints(p),from),to)
    s[,1,] <- p[,1]
    s[,2,] <- p[,2]
  }

  ## Do the binning
  bb <- bbox(r)
  nx <- ncol(r)
  ny <- nrow(r)
  xbin <- seq(bb[1,1],bb[1,2],length=nx+1)
  ybin <- seq(bb[2,1],bb[2,2],length=ny+1)

  A <- 0
  for(k in seq(length=length(dim(s)[1]))) {
    A <- A+weights[k]*table(
      factor(.bincode(s[k,2,],ybin),levels=1:ny),
      factor(.bincode(s[k,1,],xbin),levels=1:nx))
  }
  values(r) <- A
  r
}



##' Generate density estimates for time slices of a trip
##'
##' These functions allow a trip to be divided into time slices, and
##' location density estimates generated for each time slice.
##'
##' The \code{time.slices} function defines the slices into which the
##' trip is divided, and whether the primary or intermediate locations
##' are to be binned. If \code{breaks} is NULL, each location forms a
##' separate time slice, otherwise \code{breaks} divides the trip into
##' time slices in the same style as \code{\link{cut.POSIXt}}.  A
##' default set of samples and a raster defining the bin into which to
##' bin may also be specified.
##'
##' The \code{slice} function generates the binned locations for a
##' single time slice as a raster, \code{slice.interval} returns the
##' corresponding time interval, and \code{slice.indices} returns the
##' indices that will yield non null raster.
##'
##' @title Location Density Estimates
##' @param type construct density rasters for primary (\code{"x"}) or
##' intermediate (\code{"z"}) locations
##' @param slices an object generated by \code{slices} defining the
##' @param k the index of the time slice to bin.
##' @param breaks NULL, or a specification suitable for
##' \code{cut.POSIXt} to define the time slices to bin.
##' @param mcmc object generated by generated by
##' \code{estelle.metropolis} or \code{stella.metropolis}.
##' @param grid raster object that defines the sampling grid
##' @param include.lowest parameter to \code{cut.POISXt}.
##' @param right parameter to \code{cut.POSIXt}
##' @param chain NULL, or the subset of chains to bin.
##' @return \code{slice} returns the locations for time slice of the
##' track binned into a raster, \code{time.slices} returns a slices
##' object that defines the time slices into which to bin,
##' \code{slice.interval} returns the time interval spanned by a
##' slice, and \code{slice.indices} returns the valid set of indices
##' that will yield a raster.
##' @export
slice <- function(slices,k,mcmc=slices$mcmc,grid=slices$grid,chains=NULL) {
  ## Split times
  time <- mcmc$model$time
  if(!is.null(slices$breaks))
    k <- which(k==unclass(cut(if(type=="z") time[-length(time)] else time,
                 slices$breaks,
                 include.lowest=slices$include.lowest,
                 right=slices$right)))
  if(length(k)>0) {
    ## Select x or z
    if(slices$type=="z") {
      w <- diff(as.numeric(time))
      s <- mcmc$z
    } else {
      w <- rep(1,length(time))
      s <- mcmc$x
    }

    ## Subset
    w <- w[k]
    if(length(dim(s))==4) {
      s <- if(is.null(chains)) s[k,,,,drop=FALSE] else s[k,,,chains,drop=FALSE]
    } else {
      s <- s[k,,,drop=FALSE]
    }
    ## Convert
    location.rasterize(s,grid,w)
  }
}


##' @rdname slice
##' @export
time.slices <- function(type=c("x","z"),breaks=NULL,
                        mcmc=NULL,grid=raster(),
                        include.lowest=TRUE,right=FALSE) {
  r <- list(type=match.arg(type),
            breaks=breaks,
            mcmc=mcmc,
            grid=grid,
            include.lowest=include.lowest
            right=right)
  class(r) <- "slices"
  r
}


##' @rdname slice
##' @export
slice.interval <- function(slices,k,mcmc=slices$mcmc) {
  time <- mcmc$model$time
  if(!is.null(slices$breaks))
    k <- which(k==unclass(cut(if(type=="z") time[-length(time)] else time,
                 slices$breaks,
                 include.lowest=slices$include.lowest,
                 right=slices$right)))
  if(length(k)>0) range(time[if(slice$type=="z") c(k,k+1) else k])
}

##' @rdname slice
##' @export
slice.indices <- function(slices,k,mcmc=slices$mcmc) {
  time <- mcmc$model$time
  if(type=="z") time <- time[-length(time)]
  if(!is.null(breaks))
    unique(unclass(cut(time
                       slices$breaks,
                       include.lowest=slices$include.lowest,
                       right=slices$right)))
  else
    1:length(time)
}

