##' Metropolis samplers for Stella or Estelle with behaviour switching
##'
##' These functions draw samples form posterior for the simple
##' behavioural switching Stella or Estelle model by the Metropolis
##' algorithm.
##' @title Metropolis Samplers (Behaviour switching)
##' @param model a model structure as generated by
##' \code{threshold.model}.
##' @param proposal.x function for drawing proposals for x.
##' @param proposal.z function for drawing proposals for z.
##' @param x0 Starting values for twilight locations x.
##' @param z0 Starting values for intermediate locations z.
##' @param b0 Starting values for the behavioural states b.
##' @param iters number of samples to draw.
##' @param thin rate at which to thin samples.
##' @param chains number of chains to sample.
##' @param verbose report progress at prompt?
##' @return If there are r samples drawn for each of q chains of p
##' parameters at n locations, Stella will return a list containing
##' \item{\code{model}}{the model structure}
##' \item{\code{x}}{a list of n x p x r arrays of twilight locations from the q chains}
##' \item{\code{b}}{a list of (n-1) x r arrays of behavioural states from the q chains}
##' While in addition Estelle will return
##' \item{\code{z}}{a list of (n-1) x p x r arrays of intermediate locations from the q chains}.
##' @seealso \code{\link{threshold.model}}
##' @export
estelle.metropolis.switch <- function(model,
                                      proposal.x,proposal.z,
                                      x0=NULL,z0=NULL,b0=NULL,
                                      iters=1000L,thin=10L,chains=1L,
                                      verbose=interactive()) {

  ## Initialize x,z
  if(is.null(x0)) x0 <- model$x0
  if(is.null(z0)) z0 <- model$z0
  if(is.null(b0)) b0 <- model$b0
  ## Expand starting values for multiple chains
  x0 <- rep(if(is.list(x0)) x0 else list(x0),length.out=chains)
  z0 <- rep(if(is.list(z0)) z0 else list(z0),length.out=chains)
  b0 <- rep(if(is.list(b0)) b0 else list(b0),length.out=chains)

  ## Number of locations
  n <- nrow(x0[[1]])
  ## Number of parameters
  m <- ncol(x0[[1]])

  ## Extract model components
  logpx <- model$logpx
  logpz <- model$logpz
  logpb <- model$estelle.logpb
  logpB <- model$estelle.logpB
  B0 <- model$B0
  fixedx <- model$fixedx

  ## Lists of chains
  ch.xs <- vector(mode="list",chains)
  ch.zs <- vector(mode="list",chains)
  ch.bs <- vector(mode="list",chains)

  ## PARALLEL - parallelise this loop
  for(k1 in 1:chains) {
    ## Allocate chains
    ch.x <- array(0,c(n,m,iters))
    ch.z <- array(0,c(n-1L,2L,iters))
    ch.b <- array(0,c(n-1L,1L,iters))

    x1 <- x0[[k1]]
    z1 <- z0[[k1]]
    b1 <- b0[[k1]]
    ## Drop dimnames for speed
    dimnames(x1) <- NULL
    dimnames(z1) <- NULL
    dimnames(b1) <- NULL

    ## Contribution to logp from the initial x,z
    logp.x1 <- logpx(x1)
    logp.z1 <- logpz(z1)
    logp.b1 <- logpb(x1,z1,b1)

    k2 <- 0
    if(verbose) {
      cat("iter ",sprintf("%6d",k2))
      flush.console()
    }

    for(k2 in 1:iters) {

      if(verbose && k2%%10==0) {
        cat("\b\b\b\b\b\b");
        cat(sprintf("%6d",k2));
        flush.console()
      }

      for(k3 in 1:thin) {

        ## Propose all x at once, and calculate contribution to the log
        ## posterior
        x2 <- proposal.x(x1)
        x2[fixedx,] <- x1[fixedx,]
        logp.x2 <- logpx(x2)

        x <- x1
        x[c(1L,n),] <- x2[c(1L,n),]
        logp.b2 <- logpb(x,z1,b1)


        ## Update x
        ## In each case we compute full contribution (positional +
        ## behavourial) to the log posterior for current and proposed
        ## points, and apply the MH rule. If the proposal is accepted,
        ## we update both x and the cached contributions to the log
        ## posterior.


        ## Accept/reject first x
        if(!fixedx[1L]) {
          logp1 <- logp.x1[1L]+logp.b1[1L]
          logp2 <- logp.x2[1L]+logp.b2[1L]
          if(logp2-logp1 > log(runif(1))) {
            x1[1L,] <- x2[1L,]
            logp.x1[1L] <- logp.x2[1L]
            logp.b1[1L] <- logp.b2[1L]
          }
        }


        ## Accept/reject last x
        if(!fixedx[n]) {
          logp1 <- logp.x1[n]+logp.b1[n-1L]
          logp2 <- logp.x2[n]+logp.b2[n-1L]
          if(logp2-logp1 > log(runif(1))) {
            x1[n,] <- x2[n,]
            logp.x1[n] <- logp.x2[n]
            logp.b1[n-1L] <- logp.b2[n-1L]
          }
        }


        ## Red/Black update for interior x
        for(rb in 2:3) {
          is <- seq.int(rb,n-1L,by=2L)
          x <- x1
          x[is,] <- x2[is,]
          logp.b2 <- logpb(x,z1,b1)

          logp1 <- logp.x1[is]+logp.b1[is-1L]+logp.b1[is]
          logp2 <- logp.x2[is]+logp.b2[is-1L]+logp.b2[is]
          ## MH rule - compute indices of the accepted points.
          accept <- is[logp2-logp1 > log(runif(length(is)))]
          x1[accept,] <- x[accept,]
          logp.x1[accept] <- logp.x2[accept]
          logp.b1[accept] <- logp.b2[accept]
          logp.b1[accept-1L] <- logp.b2[accept-1L]

        }

        ## Update z
        ## Here we need only consider the behavioural contributions to
        ## the log posterior (the position contributions are constant
        ## and would cancel), and so we can update all the z in parallel.
        z2 <- proposal.z(z1)
        logp.z2 <- logpz(z2)
        logp.b2 <- logpb(x,z2,b1)
        logp1 <- logp.z1+logp.b1
        logp2 <- logp.z2+logp.b2
        ## MH rule - compute indices of the accepted points.
        accept <- logp2-logp1 > log(runif(n-1L))
        z1[accept,] <- z2[accept,]
        logp.z1[accept] <- logp.z2[accept]
        logp.b1[accept] <- logp.b2[accept]


        ## Update b
        logp.B <- logpB(x1,z1)
        B <- B0*exp(logp.B)
        for(i in seq_along(b1)) {
          b1[i] <- sample.int(ncol(B),1,prob=B[i,])
          logp.b1[i] <- logp.B[i,b1[i]]
        }

      }
      ## Store the current state
      ch.x[,,k2] <- x1
      ch.z[,,k2] <- z1
      ch.b[,1L,k2] <- b1
    }
    ch.xs[[k1]] <- ch.x
    ch.zs[[k1]] <- ch.z
    ch.bs[[k1]] <- ch.b
    if(verbose) cat("\n")
  }
  attr(ch.bs,"nstates") <- ncol(logp.B)
  list(model=model,x=ch.xs,z=ch.zs,b=ch.bs)
}



##' @rdname estelle.metropolis.switch
##' @export
stella.metropolis.switch <- function(model,
                                     proposal.x,
                                     x0=NULL,b0=NULL,
                                     iters=1000L,thin=10L,chains=1L,
                                     verbose=interactive()) {

  ## Initialize x
  if(is.null(x0)) x0 <- model$x0
  if(is.null(b0)) b0 <- model$b0
  ## Expand starting values for multiple chains
  x0 <- rep(if(is.list(x0)) x0 else list(x0),length.out=chains)
  b0 <- rep(if(is.list(b0)) b0 else list(b0),length.out=chains)

  ## Number of locations
  n <- nrow(x0[[1]])
  ## Number of parameters
  m <- ncol(x0[[1]])

  ## Extract model components
  logpx <- model$logpx
  logpb <- model$stella.logpb
  logpB <- model$stella.logpB
  B0 <- model$B0
  fixedx <- model$fixedx

  ## Lists of chains
  ch.xs <- vector(mode="list",chains)
  ch.bs <- vector(mode="list",chains)

  ## PARALLEL - parallelise this loop
  for(k1 in 1:chains) {
    ## Allocate chain
    ch.x <- array(0,c(n,m,iters))
    ch.b <- array(0,c(n-1L,1L,iters))

    ## Initialize
    x1 <- x0[[k1]]
    b1 <- b0[[k1]]
    ## Drop dimnames for speed
    dimnames(x1) <- NULL
    dimnames(b1) <- NULL

    ## Contribution to logp from the initial x
    logp.x1 <- logpx(x1)
    logp.b1 <- logpb(x1,b1)

    k2 <- 0
    if(verbose) {
      cat("iter ",sprintf("%6d",k2))
      flush.console()
    }

    for(k2 in 1:iters) {

      if(verbose && k2%%10==0) {
        cat("\b\b\b\b\b\b");
        cat(sprintf("%6d",k2));
        flush.console()
      }

      for(k3 in 1:thin) {

        ## Propose all x at once, and calculate contribution to the log
        ## posterior
        x2 <- proposal.x(x1)
        x2[fixedx,] <- x1[fixedx,]
        logp.x2 <- logpx(x2)

        x <- x1
        x[c(1L,n),] <- x2[c(1L,n),]
        logp.b2 <- logpb(x,b1)


        ## Update x
        ## In each case we compute full contribution (positional +
        ## behavourial) to the log posterior for current and proposed
        ## points, and apply the MH rule. If the proposal is accepted,
        ## we update both x and the cached contributions to the log
        ## posterior.


        ## Accept/reject first x
        if(!fixedx[1L]) {
          logp1 <- logp.x1[1L]+logp.b1[1L]
          logp2 <- logp.x2[1L]+logp.b2[1L]
          if(logp2-logp1 > log(runif(1))) {
            x1[1L,] <- x2[1L,]
            logp.x1[1L] <- logp.x2[1L]
            logp.b1[1L] <- logp.b2[1L]
          }
        }


        ## Accept/reject last x
        if(!fixedx[n]) {
          logp1 <- logp.x1[n]+logp.b1[n-1L]
          logp2 <- logp.x2[n]+logp.b2[n-1L]
          if(logp2-logp1 > log(runif(1))) {
            x1[n,] <- x2[n,]
            logp.x1[n] <- logp.x2[n]
            logp.b1[n-1L] <- logp.b2[n-1L]
          }
        }


        ## Red/Black update for interior x
        for(rb in 2:3) {
          is <- seq.int(rb,n-1L,by=2L)
          x <- x1
          x[is,] <- x2[is,]
          logp.b2 <- logpb(x,b1)

          logp1 <- logp.x1[is]+logp.b1[is-1L]+logp.b1[is]
          logp2 <- logp.x2[is]+logp.b2[is-1L]+logp.b2[is]
          ## MH rule - compute indices of the accepted points.
          accept <- is[logp2-logp1 > log(runif(length(is)))]
          x1[accept,] <- x[accept,]
          logp.x1[accept] <- logp.x2[accept]
          logp.b1[accept] <- logp.b2[accept]
          logp.b1[accept-1L] <- logp.b2[accept-1L]
        }

        ## Update b
        logp.B <- logpB(x1)
        B <- B0*exp(logp.B)
        for(i in seq_along(b1)) {
          b1[i] <- sample.int(ncol(B),1,prob=B[i,])
          logp.b1[i] <- logp.B[i,b1[i]]
        }

      }
      ## Store the current state
      ch.x[,,k2] <- x1
      ch.b[,1L,k2] <- b1
    }
    ch.xs[[k1]] <- ch.x
    ch.bs[[k1]] <- ch.b
    if(verbose) cat("\n")
  }
  attr(ch.bs,"nstates") <- ncol(logp.B)
  list(model=model,x=ch.xs,b=ch.bs)
}


##' Summarize a set of behavioural state samples
##'
##' The functions compute various summaries of a sample or list of
##' samples of behavioural states generated by
##' \code{estelle.metropolis.switch} or
##' \code{stella.metropolis.switch}.
##'
##' These functions accept either a sample from a single mcmc run, or
##' a list of samples from parallel mcmc runs.  When \code{collapse}
##' is true, multiple samples are merged and single result is
##' returned, otherwise a result is returned for each sample.
##'
##' @rdname behaviour.prob
##' @title Summaries of Behavioural Samples
##' @param s a single chain or a list of parallel chains of
##' behavioural states generated by \code{estelle.metropolis.switch}
##' or \code{stella.metropolis.switch}.
##' @param discard number of initial samples to discard.
##' @param collapse whether to collapse multiple chains to a single sample
##' @param chains the set of chains to retain, or \code{NULL}.
##' @return
##' \item{\code{behaviour.prob}}{returns an array or a list of
##' arrays of the probabilities of each behavioural state in each interval.}
##' \item{\code{location.mean}}{returns an vector or a list of vectors
##' of the most likely behvarioual state in each interval.}
##' @export
behaviour.prob <- function(s,discard=0,collapse=TRUE,chains=NULL) {
  nstates <- attr(s,"nstates")
  prob <- function(s) t(apply(s,1,tabulate,nbins=nstates)/ncol(s))

  s <- chain.collapse(s,collapse=collapse,discard=discard,chains=chains)
  if(is.list(s)) lapply(s,prob) else prob(s)
}


##' @rdname behaviour.prob
##' @export
behaviour.class <- function(s,discard=0,collapse=TRUE,chains=NULL) {
  nstates <- attr(s,"nstates")
  prob <- function(s) apply(s,1,function(p) which.max(tabulate(p,nbins=nstates)))

  s <- chain.collapse(s,collapse=collapse,discard=discard,chains=chains)
  if(is.list(s)) lapply(s,prob) else prob(s)
}


